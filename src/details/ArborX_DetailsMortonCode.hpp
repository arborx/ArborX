/****************************************************************************
 * Copyright (c) 2017-2022 by the ArborX authors                            *
 * All rights reserved.                                                     *
 *                                                                          *
 * This file is part of the ArborX library. ArborX is                       *
 * distributed under a BSD 3-clause license. For the licensing terms see    *
 * the LICENSE file in the top-level directory.                             *
 *                                                                          *
 * SPDX-License-Identifier: BSD-3-Clause                                    *
 ****************************************************************************/

#ifndef ARBORX_DETAILS_MORTON_CODE_UTILS_HPP
#define ARBORX_DETAILS_MORTON_CODE_UTILS_HPP

#include <ArborX_DetailsKokkosExtMinMaxOperations.hpp> // min. max
#include <ArborX_Point.hpp>

namespace ArborX
{

namespace Details
{

// Magic numbers generated by the script in
// https://stackoverflow.com/questions/1024754/how-to-compute-a-3d-morton-number-interleave-the-bits-of-3-ints/18528775#18528775

// Insert one 0 bit after each of the 16 low bits of x
KOKKOS_INLINE_FUNCTION
unsigned int expandBitsBy1(unsigned int x)
{
  x &= 0x0000ffffu;
  x = (x ^ (x << 8)) & 0x00ff00ffu;
  x = (x ^ (x << 4)) & 0x0f0f0f0fu;
  x = (x ^ (x << 2)) & 0x33333333u;
  x = (x ^ (x << 1)) & 0x55555555u;
  return x;
}

// Insert one 0 bit after each of the 31 low bits of x
KOKKOS_INLINE_FUNCTION
unsigned long long expandBitsBy1(unsigned long long x)
{
  x &= 0x7fffffffllu;
  x = (x | x << 16) & 0x7fff0000ffffllu;
  x = (x | x << 8) & 0x7f00ff00ff00ffllu;
  x = (x | x << 4) & 0x70f0f0f0f0f0f0fllu;
  x = (x | x << 2) & 0x1333333333333333llu;
  x = (x | x << 1) & 0x1555555555555555llu;
  return x;
}

// Insert two 0 bits after each of the 10 low bits of x
KOKKOS_INLINE_FUNCTION
unsigned int expandBitsBy2(unsigned int x)
{
  x &= 0x000003ffu;
  x = (x ^ (x << 16)) & 0xff0000ffu;
  x = (x ^ (x << 8)) & 0x0300f00fu;
  x = (x ^ (x << 4)) & 0x030c30c3u;
  x = (x ^ (x << 2)) & 0x09249249u;
  return x;
}

// Insert two 0 bits after each of the 21 low bits of x
KOKKOS_INLINE_FUNCTION
unsigned long long expandBitsBy2(unsigned long long x)
{
  x &= 0x1fffffllu;
  x = (x | x << 32) & 0x1f00000000ffffllu;
  x = (x | x << 16) & 0x1f0000ff0000ffllu;
  x = (x | x << 8) & 0x100f00f00f00f00fllu;
  x = (x | x << 4) & 0x10c30c30c30c30c3llu;
  x = (x | x << 2) & 0x1249249249249249llu;
  return x;
}

template <int DIM>
unsigned int morton32(PointD<DIM> const &p);

// Calculate a 32-bit Morton code for a 2D point located within [0, 1]^2.
template <>
KOKKOS_INLINE_FUNCTION unsigned int morton32<2>(PointD<2> const &p)
{
  // The interval [0,1] is subdivided into 65,536 bins (in each direction).
  constexpr unsigned N = (1u << 16);

  using KokkosExt::max;
  using KokkosExt::min;

  auto x = min(max(p[0] * N, 0.f), (float)N - 1);
  auto y = min(max(p[1] * N, 0.f), (float)N - 1);

  return 2 * expandBitsBy1((unsigned int)x) + expandBitsBy1((unsigned int)y);
}

// Calculate a 30-bit Morton code for a 3D point located within [0, 1]^3.
template <>
KOKKOS_INLINE_FUNCTION unsigned int morton32<3>(PointD<3> const &p)
{
  // The interval [0,1] is subdivided into 1024 bins (in each direction).
  constexpr unsigned N = (1u << 10);

  using KokkosExt::max;
  using KokkosExt::min;

  auto x = min(max(p[0] * N, 0.f), (float)N - 1);
  auto y = min(max(p[1] * N, 0.f), (float)N - 1);
  auto z = min(max(p[2] * N, 0.f), (float)N - 1);

  return 4 * expandBitsBy2((unsigned)x) + 2 * expandBitsBy2((unsigned)y) +
         expandBitsBy2((unsigned)z);
}

template <int DIM>
unsigned long long morton64(PointD<DIM> const &p);

// Calculate a 62-bit Morton code for a 2D point located within [0, 1]^2.
template <>
KOKKOS_INLINE_FUNCTION unsigned long long morton64<2>(PointD<2> const &p)
{
  // The interval [0,1] is subdivided into 2,147,483,648 bins (in each
  // direction).
  constexpr unsigned N = (1u << 31);

  using KokkosExt::max;
  using KokkosExt::min;

  // Have to use double as float is not sufficient to represent large integers,
  // which would result in some missing bins.
  auto xd = min(max((double)p[0] * N, 0.), (double)N - 1);
  auto yd = min(max((double)p[1] * N, 0.), (double)N - 1);

  return 2 * expandBitsBy1((unsigned long long)xd) +
         expandBitsBy1((unsigned long long)yd);
}

// Calculate a 63-bit Morton code for a 3D point located within [0, 1]^3.
template <>
KOKKOS_INLINE_FUNCTION unsigned long long morton64<3>(PointD<3> const &p)
{
  // The interval [0,1] is subdivided into 2,097,152 bins (in each direction).
  constexpr unsigned N = (1u << 21);

  using KokkosExt::max;
  using KokkosExt::min;

  // float is sufficient to represent all integers up to 16,777,216 (2^24),
  // which is greater than N. So there is no need to use double here.
  auto x = min(max(p[0] * N, 0.f), (float)N - 1);
  auto y = min(max(p[1] * N, 0.f), (float)N - 1);
  auto z = min(max(p[2] * N, 0.f), (float)N - 1);

  return 4 * expandBitsBy2((unsigned long long)x) +
         2 * expandBitsBy2((unsigned long long)y) +
         expandBitsBy2((unsigned long long)z);
}

} // namespace Details

} // namespace ArborX

#endif
